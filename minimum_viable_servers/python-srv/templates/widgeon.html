<!doctype html>

<html> <!--:url('static/bg/pt3.png')  -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <script src="static/wkmap_uncollector.js"></script>
    <script src="static/d3.v2.min.js"></script>
    <style>
      #map { 
        overflow:hidden; 
        position:absolute; 
        height:90%; 
        width:90%; 
        top:5%; 
        left:5%; 
        border: 5px solid rgba(11,11,11,.5); 
      }
    </style>      
  </head>
<body>
<div id=map>
</div>
<script>

var mapContainer = d3.select("#map").node()

/*  wkmap returns object with 2 functions:
    1) `tile` function that takes [[lon, lat], zoom] and returns its tms tile [Z, X, Y],
    2)  a `render` function that takes a Well-Known Binary ArrayBuffer, a canvas element, a tile
    coordinate object of the form {x: TMS-X-Coord, y: TMS-Y-Coord}, and a Zoom (integer).

    The dom stuff is all d3.js and is partly an exercise in studying that library
*/

var map = wkmap()
  , position = { geography:[-122.42, 37.76], browser:[0,0], anchor: null}
  , zoom0 = 13
  , height = mapContainer.clientHeight
  , width = mapContainer.clientWidth
  , xVisible = Math.ceil(width/512)  // tile count left, right of center
  , yVisible = Math.ceil(height/512) 
  , wkbCache = {}
  
function flaskProvider (baseUrl) {
  function mkurl (tile) {
    return baseUrl + tile.join('/')+'.wkb'
  }
  return mkurl
}

var overlay = flaskProvider("/api/osmline/")

function displayedTiles (ctr, xmin, ymin, xmax, ymax) {
console.log(ctr, xmin, ymin, xmax, ymax) 
  if (!position.anchor) position.anchor = ctr
  var rv = []
    , xmin = xmin || (xVisible * -1)
    , ymin = ymin || (yVisible * -1)
    , xmax = xmax || xVisible
    , ymax = ymax || yVisible
  for (var i = xmin; i <= xmax; i++) {
    for (var j = ymin; j <= ymax; j++) {
      rv.push({tms:[ctr[0], ctr[1]+i, ctr[2]+j], 
        pos:[i,j]})
    }
  }
  return rv
}

var seen = {}

var panWest = 1

function panEdge(d) {}  

var dragmap = d3.behavior.drag()
    .on("drag", function (d, i) {
      position.browser[0] += d3.event.dx
      position.browser[1] += d3.event.dy
      if (position.browser[0] < -256*panWest) {
        for (var i = yVisible*(-1); i < yVisible; i++) {
          var tl = {tms:[zoom0, position.anchor[1] + xVisible + panWest, position.anchor[2] + i]}
          if (!seen[overlay(tl.tms)]) {
            inView.push({tms:[zoom0, position.anchor[1] + xVisible + panWest, position.anchor[2] + i]})
            seen[overlay(tl.tms)] = true
          }
        }
        panWest++
        display()
      }
      d3.selectAll(".maptile")
        .style("top", function () {
              return (parseInt(d3.select(this).node().style.top) + 
                      d3.event.dy).toString() + 'px'
        })
        .style("left", function () {
              return (parseInt(d3.select(this).node().style.left) + 
                      d3.event.dx).toString() + 'px'
        })
      })
 

// this should become something like modestmaps concept of provider
// better version along those lines in master/minimum_viable_servers/couch

function tilepos (el, tile) {
  d3.select(el)
  .style('top', function () { console.log(this);
     return (height/2 + (Number(d3.select(this).attr('row')) - position.anchor[2])*256 + position.browser[1]).toString() + 'px'
    })
    .style('left', function () {
      return (height/2 + (Number(d3.select(this).attr('col')) - position.anchor[1])*256 + position.browser[0]).toString() + 'px'
    })
}


function xharr (tile, el, callback) { // tee hee
  var buf = new XMLHttpRequest
    , url = overlay(tile)
  if (url in wkbCache) {
    callback(wkbCache[url], el, {x:tile[1], y:tile[2]}, tile[0])
    return
  }
  buf.open("GET", url, true)
  buf.responseType = 'arraybuffer'
  buf.onload = function (evt) {
    if ('function' === typeof callback && buf.response) {
      wkbCache[url] = buf.response
      callback(buf.response, el, {x:tile[1], y:tile[2]}, tile[0])
      tilepos(el, tile)
    } else { 
    }
  }
  buf.send(null)
  return el
}

var inView =  displayedTiles(map.tile(position.geography, zoom0))

// will be once per layer
function display () {
  d3.select("#map").selectAll("canvas")
    .data(inView)
   .enter()
    .append("canvas")
    .attr("class", "maptile")
    .attr("height", "256px")
    .attr("width", "256px")
    .attr("row", function (d) { return d.tms[2] })
    .attr("col", function (d) { return d.tms[1] })
    .style("position", "absolute")
    .attr("id", function (d) { xharr(d.tms, d3.select(this).node(), map.render);  return 'tile-'+d.tms.join('-') })
    .call(dragmap)
  }

function redisplay () {
  d3.select("#map").selectAll("canvas")
    .data(inView)
    //.update()
    //.append("canvas")
    .attr("class", "maptile")
    .attr("height", "256px")
    .attr("width", "256px")
    .attr("row", function (d) { return d.tms[2] })
    .attr("col", function (d) { return d.tms[1] })
    .style("position", "absolute")
    .style("top", function (d) { console.log('redisplaying');
        d.y = (height/2 + (d.tms[2] - position.anchor[2])*256 + position.browser[1])
        return d.y.toString() + 'px' 
      })
    .style("left", function (d) { 
        d.x = (width/2 + (d.tms[1] - position.anchor[1])*256 + position.browser[0])
        return d.x.toString() + 'px' 
      })
    .attr("id", function (d) { xharr(d.tms, d3.select(this).node(), map.render);  return 'tile-'+d.tms.join('-') })
    //.style("background", function (d) { return "rgba(11,11,11,.4)" })
    .call(dragmap)
  }

display(inView)

</script>
</body>
</html>
